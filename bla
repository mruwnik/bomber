object.h

Action opisuje ruchy. None oznacza zeby nic nie robic, fly jest dla latajacych stworow i oznacza, ze nie mozna tutaj przejsc ale mozna przeleciec. up,right, down i left sa po to by przekazac chec przejscia w danym kierunku. mov oznacza, ze droga jest wolna i ze mozna tutaj przejsc. kill oznacza ze object ktory takowy sygnal dostal musi umrzec.

enum action{none=0,fly,up,right,down,left,mov,kill};

Klasa bazowa wszystkich objektow na planszy. Przechowuje znak objektu (czy obrazek albo co innego - zalezy od implementacji grafiki) oraz licznik ktory przechowuje ilosc tur zanim mozna wykonac ruch.

class object{
	char symbol; // symbol objektu
public:
	int counter; // zmieniajac ta wartosc mozna ustalac predkosc objektu
	object(char c, unsigned long int = A_NORMAL, int t=0);
	void changeSymbol(char);
	virtual int move();// obsluguje dzialanie objektu
	virtual action request(object*) = 0; // do zapytania czy moze objekt sie przesunac
	virtual void die(); // zabija obiekt ( jezeli to mozliwe )
	virtual void setid(int){} // ustawia id objektu
	virtual void getid(){} // dostaje nowy id przy wpisaniu do listy aktywnych objektow
	virtual void print(); // wypisuje objekt na ekran
	virtual ~object();
};



board.h

Tutaj sa klasy ktore dziala wprost na plansze.

Sciana niezniszalna. Na plansie wystepuja wskazniki na tylko 1 okaz, bo i tak w zaden sposob nie jest modifikowana

struct Wall : public object{
	Wall();
	action request(object* o);
	~Wall(){};
};	

Klasa ktora przechowuje plansze. Plansza jest tablica dwuwymiarowa wskaznikow na obiekty typu 'object' po ktory wszelakie inne objekty dziedzicza ( klasa object jest abstrakcjna). Jest takze w tej klasie lista (ktora jest w sumie wektorem) w ktorej sa zapisane te objekty ktore aktywnie cos robia (graczy, stwory, itp.). Jedna runda polega na przejsciu przez owa liste i wywolanie dla kazdego objektu jego funkcje move() ktora powoduje, ze dany objekt wykonuje swoj ruch

class Board{
	object*** board;	// sama tablica
	int n,m,players,baddys,over; // wysokosc, szerokosc planszy; ile zostalo graczy, stworow; czy juz ktos wygral
	Wall wall;		// egzemplarz sciany niezniszczalnej ktora jest na plaszy
	List<object> list;	// lista ( w sumie wektor ) objektow aktywnych
	Board(const Board&){};	// likwiduje mozliwosc skopiowania tablice
public:
	Board(int n, int m);	
	int round();		// wywoluje funkcje move() dla kazdego objektu listy
	void print();		// wyswietla obecny stan gry
	int add2list(object*);	// dodaje objekt do listy
	object* dellist(int i);	// usuwa i-ty element z listy, ale nie usuwa samego objektu - to musi zrobic sam objekt
	action movebeing(int x,int y,action kier); // probuje przesunac object o wsp. (x,y) o 1 miejsce w kierunku 'kier'
	object* check(int x,int y);	// zwraca wskaznik na objekt pod wsp. (x,y)
	object* place(object*,int x,int y);	// probuje klasc objekt na board[x,y], jezeli sie nie da to go usuwa i zwraca 0
	void remove(int x,int y);	// usuwa objekt pod wsp. (x,y)
	void playerDown();	// dekrementuje zmienna players przy smierci gracza
	void baddyDown();	// to samo dla stworkow
	int checkBaddys();	// zwraca ilosc stworow na plansie
	void end(int x, int y);	// konczy gre na obecnej plansie
	friend class initialiser; // klasa ktora inicjalizuje plansie
	friend class twin;	// umozliwia postawienia 2 objekty na 1 polu planszy
	~Board();
};

Klasa ktora przechowuje pozycje objektu na plansie i posredniczy miedzy objektem a plansza,

class pos{
protected:
	static int n,m; // wysokosc i dlugosc planszy
	int x,y;	// pozycja objektu na planszy
	signed int id;	// identyfikator objektu ( jezeli jest wiekszy niz -1 to jest to pozycja w liscie aktywnych objektow)
	static Board* board; // wskaznik na plansze
public:
	pos(int x,int y);
	action move(action);	// probuje wykonacz przekazana akcje (przesunac sie albo umrzecz)
	static void set(Board*,int,int);	// ustawia paramentry planszy
	void getid(object*);	// wstawia objekt do listy aktywnych objektow, ustawiajac przy tym jego nr identyfikacjny
	void setid(int);	// ustawia nr id., przy czym jezeli jest mniejszy niz 0 to wypisuje objekt z list aktywnych objektow	
	void remove();		// uzywana przy smierci stwora by zawiadomic planszy, ze jest o jeden stworek mniej
	~pos();
};


initialiser.h

Klasa ta jest odpowiedzialna za wlasciwa inicjalizacje planszy oraz za obsluge menu gry.

class initialiser{
	Board& b;	// referencja na plansze
	player* p[4];	// tablica wskaznikow na graczy
public:
	initialiser(Board& bo);
	void operator()(const Board& bo);	// zmienia plansze
	object* add(object* o, int x, int y);	// dodaje dowolny element do tablicy pod wspl. (x,y)
	Board* menu();				// menu gry
	Board* newgame();			// odpowiada za tworzenie nowej gry
	void fill(int f=0);			// wypelnia plansze
	int play(int type=0);			// dodaje gracza. Domyslnie gracz jest czlowiekiem (w sumie tylko to dziala)
	int baddys(int type, int amount=1);	// dodaje 'amount' stworkow typu ' type'. Obecnie jest tylko 1 typ stworka
};

list.h

Kontener ktory w sumie jest wektorem, tyle ze przy usuniecia ze srodka to zamiast przesunac w lewo wszystkie elementy tablicy lezace na prawo od usuwanej wartosci, to poprostu wstawia w pusta miejsce ostatni element.

template<class T>
class List{
	int quantity; //liczba elementow pamieci
	int next; //nastepny pusty element
	T** storage; //tablica wskaznikow na objekty ktore beda cos robily
	void inflate(int increase = 10); // powieksza tablice o 'increase'
public:
	List() : quantity(0), next(0), storage(0) {};
	int add(T*);			// dodaje element do tablicy i zwraca jego pozycje w tablicy
	T* operator[](int index) const; // pobiera storage[index]
	T* remove(int index); 		// usuwa storage[index] z tablicy, przy czym nie usuwa z pamieci
	~List();
};


blok.h

Klasa ta obsluguje wszelakie bonusy. Nalezy ja zadeklarowac z znakiem jakim bedzie mialo na planszy oraz ze funkcja skladowa klasy gracza ktora bedzie odpowiedzialna za modifikacji parametrow gracza ktory napotka na ten bonus.

class bonus: public object{
	char c;		//znak wypisywany na ekran po rozwaleniu sciany
	void (player::*f)();// wskaznik na funkcje skladowa gracza
protected:
	int dead;	// pamieta czy sciana rozwalona czy nie
	pos p;		// pozycja bonusa na planszy
public:
	bonus(int x, int y, char c, void (player::*f)());
	action request(object *);// obsluguje prosby by sie przesunac
	void die();		// rozwala sciane, ewentualnie bonusa
};

Klasa pomocnicza do drzwi - przechowuje je pozycja na planszy 

struct doorpos: public pos{
	doorpos(int x, int y);
	int checkbaddys();	// sprawdza czy jakies stwory zostaly na planszy
	void victory();		// konczy gre na obecnej planszy, mozna tutaj dawac efekty koncowe
};

Drzwi. Jezeli nie bedzie juz stworkow na planszy i drzwi sa odkryte, to przejscie przez nie oznacza przejscie do nastepnej
planszy. 

class door: public object{
	int id;		// identyfikator w liscie aktywnych obiektow ( co ture sprawdza czy jeszcze sa stworki )
	int dead;	// czy sciana zakrywajaca drzwi zostala juz rozwalona
	char c;		// symbol drzwi po rozwaleniu sciany ktora je ukrywa
	doorpos p;	// pozycja drzwi na planszy
public:
	door(int x, int y, char c='X');
	int move();		// sprawdza czy jeszcze sa stworki, jezeli nie i drzwi sa zakryte, to daje wskazowke gdzie sa
	action request(object *);// obsluguje obiekty ktore napotkaja na drzwi
	void die();		// jezeli drzwi jeszcze nie sa odkryte, to je odkrywa
	void setid(int);	// ustawia identyfikator drzwi (uzywane przy sortowaniu liste aktywnych obiektow)
};

Zwykla sciana. Jezeli sie ja rozwali to jest puste pole na planszie.

class blok : public object{
	pos p;		//pozycja na planszie
public:
	blok(int x, int y,char c='X');
	void die();	// rozwala sciane
	action request(object* o); // informuje napotkane obietkom, ze nie ma przejscia (chyba, ze umia latac)
	~blok();
};




player.h

Prosta klasa ktora przechowuje kody klawiszowe poszczegolnych przyciskow sterujacych.

struct knefle{
	knefle(int,int,int,int,int);
	knefle();
	knefle& operator=(const knefle&);
	int up, right, down, left, bomb;
};

Pozycja gracza - takze pozwala postwic bomby i przy smierci gracza powiadomia planszy, ze jest 1 gracza mniej.

struct playerpos : public pos{
	playerpos(int x, int y);
	bomba* spawnbomb(object*,int);	// postawia bombe pod graczem
	void remove();			// powiadomia plansze o smierci gracza
	~playerpos();
};

Klasa gracza. Posiada liste swoich postawionych bomb i jest odpowiedzialny za to by je wysadzic. Jezeli umrze ale zostawi bomby na plansze to przekazuje je do listy objektow aktywnych aby sie wysadzily w odpowiednim momencie. Jest to tak zrobione by mozna bylo latwo sledzic stan wszystkich bomb danego gracza, a tak ze po to by umozliwic dolozenia bonusa ktory by pozwalal bomby wysadzac zdalnie zamiast na czas.

class player : public object{
	playerpos p;
	List<bomba> list;// tablica bomb - jak postawi sie bombe to zostaje on przechowany w owej tablicy
	int range,bombs,speed;	// zasieg bomby, ilosc bomb oraz predkosc gracza
	knefle k;		// kody klawiszowe poszczegolnych przyciskow uzywane do sterowania graczem
public:
	player(int x, int y, knefle k, int t=7);
	void addbomb();		// bonusowa bomba
	void incrange();	// bonus dajacy +1 do zasiegu
	void stim();		// bonus przyspieszajacy gracza
	void die();		// zabija gracza ( moznaby wykorzystac jako 'bonus' :D )
	int move();		// obsluguje ruchy gracza
	void setid(int);
	void getid();
	void setkeys(const knefle&); // za pomoca tej funkcji mozna zmienic klawisze sterujace
	action request(object*);// do pytania sie o usuniecia sie z drogi	
	~player();
};

baddy.h

Klasa bazowa wszystkich potworow. Wystarczy dzedziczyc po niej i zmienic znak i predkosc w konstruktorze oraz predefiniowac funkcje move(). Mozna takze zrobic latajace stwory, ale to jest o ciut trudniej. aby rozwiazac problem 2 obiektow na tym samym polu zrobiono klase twin. Mozna zobaczyc jak ja uzywac na podstawie klasy bomba, przyczym nalezalo by zamiast bomby wstawic mur, a zamiast gracza latajacy stworek.

class baddy : public object{
	int speed;  // predkosc stworka
	pos p;	    // pozycja stworka na planszy
public:
	baddy(int x,int y,char c,int s=10);// x,y - wspol. stwora, c - jak on wyglada na planszy, s - predkosc stwora
	void die();	// bezwzglednie zabija stwora
	int move();	// funkcja odpowiedzialna z ruch stwora
	void setid(int);// ustala identifikator stwora
	action request(object* o); // przyjmuje prosby o usuniecia sie z drogi
	~baddy();
};


twin.h

Jest to klasa ktora pozwala postawic 2 objekty na jednym polu planszy.

class twin : public object{
	static Board* board;
	int x,y,id,f;	// wspol. (x,y), identyfikator w liscie objektow aktywnych, znacznik ktorego objektu nalezy usunac
	object* one;	// wskaznik na objekt nieaktywny, lezacy na dole (np. sciana albo bomba)
	object* two;	// wskaznik na objekt aktywny, lezacy na gorze (np. latajacy stworek albo gracz)
public:
	twin(object* o, object* t, int x, int y);
	static void set(Board*);	// ustawia wskaznik na plansze
	action request(object* o);	// przyjmuje prosby o przesuniecia sie
	int move();			// kaze drugiemu objektowi zrobic ruch
	void print();			
	void die();			// usuwa odpowiedni objekt ( f==0 ? one->die() : two->die() )
	void setid(int i);		
	~twin();
};




bomb.h

Oginiki z wybuchu bomby. Zamiast szybkosc przechowuja licznik ktory okresla ile jeszcze czasu maja do zycia. Gdy licznik dojdzie do 0, to zamiast wykonacz ruch poprostu znikaja. Jezeli ktos napotka sie na ognia to umiera; ogien rozwala wszystko oprocz sciany niezniszczalne.

class fire : public object{
	pos p;	// pozycja ognia na planszy
public:
	fire(int x, int y,int t=8);
	int move();		 // sprawdza czy powinnien juz zniknac
	action request(object*); // gdy ktos sie na niego napotka to go zabija
	void setid(int);	
	~fire();
};

Klasa bomba ma swoja klase typu pos poniewaz ma nieco inne dzialanie niz typowy objekt. W tej klasie sa tworzone ogniki przy wybuchu (w funkcji move() ). Przy wybuchu ognien sie rozprzestrzenia na 'range' pole w kazda strone, chyba ze predzej napotka przeszkode. Jezeli cos napotka to wysyla do tego czego sygnal die() i na tym konczy swoje dzielo. Jezeli ten rzecz moze zostac zniszczony to znika i zostaje puste pole, bonus albo ewentualnie drzwi.

class bombpos : public pos{ 
	int range;	// zasieg bomby ( ile ognikow stworzy)
public:
	bombpos(int x,int y, int r);
	int move(action);	// jezeli bomba ma wybucnac to ta funkcja jest odpowiedzialna za tworzenie ogniki
	void setid(int);
};

Bomba. Przy stworzeniu jest na tym samym polu co gracz, wybucha po 'r' turach. Jedyny rzecz na co odpowiada to ogien i wtedy wybucha.

class bomba : public object{
	bombpos p;	// pozycja bomby na planszy
public:
	bomba(int x, int y, int r);
	int move();	// sprawdza czy wybuchnac juz
	void setid(int);	
	void getid();
	int count(){return object::counter;} //	zwraca ile tur zostalo do wybuchu
	action request(object * o);
	void die();	// wysadza bombe
	~bomba();
};

